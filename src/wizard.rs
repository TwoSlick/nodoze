use std::io::{self, Write};

use crate::audio;
use crate::config::Config;

/// Run the interactive configuration wizard
pub fn run() -> Result<(), String> {
    println!();
    println!("NoDoze Configuration Wizard");
    println!("───────────────────────────");
    println!();

    let defaults = Config::default();

    let frequency = prompt_f64("Frequency in Hz", defaults.frequency)?;
    let duration = prompt_u64("Duration in seconds", defaults.duration)?;
    let interval = prompt_u64("Interval in seconds", defaults.interval)?;
    let fade_duration = prompt_f64("Fade duration in seconds", defaults.fade_duration)?;
    let volume = prompt_volume("Volume 0-100%", (defaults.volume * 100.0) as u64)?;
    let device = prompt_device()?;

    let config_path = Config::config_path()
        .ok_or_else(|| "Could not determine config directory".to_string())?;

    if let Some(parent) = config_path.parent() {
        std::fs::create_dir_all(parent)
            .map_err(|e| format!("Failed to create config directory: {}", e))?;
    }

    let device_line = if device.is_empty() {
        "device = \"\"".to_string()
    } else {
        format!("device = \"{}\"", device)
    };

    let contents = format!(
        r#"# NoDoze Configuration
# Generated by: nodoze setup

# Frequency of the tone in Hz (20 Hz is near the bottom of human hearing)
frequency = {frequency}

# Duration of each tone in seconds
duration = {duration}

# Interval between tones in seconds (540 = 9 minutes)
interval = {interval}

# Fade in/out duration in seconds (prevents clicks/pops)
fade_duration = {fade_duration}

# Volume (0.0 to 1.0) — 0.05 = 5%, enough to keep speakers awake without distortion
volume = {volume}

# Audio output device name (empty string = system default)
# Use `nodoze list-devices` to see available devices
{device_line}
"#
    );

    std::fs::write(&config_path, contents)
        .map_err(|e| format!("Failed to write config: {}", e))?;

    println!();
    println!("Config written to {}", config_path.display());
    println!();

    Ok(())
}

fn prompt_f64(label: &str, default: f64) -> Result<f64, String> {
    let input = prompt_raw(&format!("{} [{}]", label, default))?;
    if input.is_empty() {
        return Ok(default);
    }
    input
        .parse::<f64>()
        .map_err(|_| format!("Invalid number: {}", input))
}

fn prompt_u64(label: &str, default: u64) -> Result<u64, String> {
    let input = prompt_raw(&format!("{} [{}]", label, default))?;
    if input.is_empty() {
        return Ok(default);
    }
    input
        .parse::<u64>()
        .map_err(|_| format!("Invalid number: {}", input))
}

fn prompt_volume(label: &str, default_pct: u64) -> Result<f64, String> {
    let input = prompt_raw(&format!("{} [{}]", label, default_pct))?;
    let pct = if input.is_empty() {
        default_pct as f64
    } else {
        input
            .parse::<f64>()
            .map_err(|_| format!("Invalid number: {}", input))?
    };
    if !(0.0..=100.0).contains(&pct) {
        return Err("Volume must be between 0 and 100".to_string());
    }
    Ok(pct / 100.0)
}

fn prompt_device() -> Result<String, String> {
    let devices = audio::list_devices()?;

    if devices.is_empty() {
        println!("  No output devices found, using system default.");
        return Ok(String::new());
    }

    println!();
    println!("Available output devices:");
    println!("  1. System default");
    for (i, name) in devices.iter().enumerate() {
        let clean = name.strip_suffix(" (default)").unwrap_or(name);
        println!("  {}. {}", i + 2, clean);
    }
    println!();

    let input = prompt_raw("Device [1]")?;

    let chosen: usize = if input.is_empty() {
        1
    } else {
        input
            .parse()
            .map_err(|_| format!("Invalid selection: {}", input))?
    };

    if chosen < 1 || chosen > devices.len() + 1 {
        return Err(format!("Selection {} out of range", chosen));
    }

    if chosen == 1 {
        Ok(String::new())
    } else {
        let device_name = &devices[chosen - 2];
        let clean = device_name.strip_suffix(" (default)").unwrap_or(device_name);
        Ok(clean.to_string())
    }
}

fn prompt_raw(label: &str) -> Result<String, String> {
    print!("  {}: ", label);
    io::stdout()
        .flush()
        .map_err(|e| format!("IO error: {}", e))?;

    let mut input = String::new();
    io::stdin()
        .read_line(&mut input)
        .map_err(|e| format!("Failed to read input: {}", e))?;

    Ok(input.trim().to_string())
}
